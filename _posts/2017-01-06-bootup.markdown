---
layout: post
title: "Part 1: Bootup to LED"
date: 2017-01-06 12:23:00 -0800
Categories: teensy
---

This post explains how to get a minimal application booting on a
Teensy 3.1 or 3.2. The [Teensy][teensy] is based on a Freescale (NXP)
MK20DX256 ARM Cortex-M4 microcontroller (μC). Further blog posts will
explain how to access the various hardware features of this μC. The
goal of this tutorial series is to teach how to build safe hardware
abstractions in Rust. As such, existing libraries for embedded devices
will not be used.

This tutorial is written mostly for Linux; specifically Arch. You may
have to adjust paths for other OSes, or even for other Linux
distros. If anything is broken for you, please feel free to [file an
issue][gh-issue] on GitHub.

# Overview

Unlike on a PC, the boot sequence for the MK20DX256 is fairly
straightforward. It will load its *interrupt table* from the beginning
of the flash, and call whichever function is the *reset vector*.

The *interrupt table* is an array of functions. When certain events
occur, the processor will look up the appropriate entry in the array,
and call that function. Each index in this array is called a
*vector*. Thus, the *reset vector* is the function associated with the
"reset" event of the μC. There are up to 256 interrupt vectors - the
first 16 are standard across all Cortex-M4 devices and the remainder
are specific to a given chip, based on the peripherals and features it
has available. We'll discuss interrupts in more detail in a future
post.

To get a working boot environment, we need to do the following:

* Create a list of function pointers at the beginning of flash
* Make sure that our startup function is in the correct place in that
  list for it to be called on reset
* Do something useful with that function, so we know it was called

In our case, the "do something useful" will be turning on the Teensy's
LED. Future posts will enable more interesting functionality.

In addition to being in the interrupt table, our main function will
also have to disable the *watchdog* and enable the appropriate
*clock*. The watchdog is a special circuit in the μC that makes sure a
program is continuing to execute as intended. It's actually very
useful in real-world embedded development, but for this tutorial it
creates too much complexity, so we'll turn it off.We'll discuss
*clocks* in-depth in a future post. For now, think of them as on-off
switches for a given piece of chip functionality.

# Prerequisites

To build a Rust program that targets the Teensy, we'll need to make a
couple of changes from a normal Rust environment. I'll be assuming
that you use rustup to manage your Rust toolchain.

First, we'll install a tool called [xargo][xargo]. Xargo is a wrapper
around Cargo that provides some extra smarts when cross-compiling.

{% highlight shell %}
$ cargo install xargo
{% endhighlight %}

Once installed, Xargo is available at `~/.cargo/bin/xargo`. It's not
necessary to put this on your `PATH` for this tutorial series, as
we'll be using a Makefile to call it.

Next, we'll need to configure rustup to install the Rust
sources. Xargo uses these sources to build a `libcore` for our target
architecture.

{% highlight shell %}
$ rustup component add rust-src
{% endhighlight %}

We'll also need Rust nightly. This series does not use any unstable
language features, but a nightly Rust is required in order to
implement [lang items][lang-item], as well as for the occasional bits
of inline assembly that embedded development requires. This makes
nightlies necessary for all embedded development in Rust.

{% highlight shell %}
$ rustup toolchain install nightly
{% endhighlight %}

Finally, we'll want ARM-targetting versions of GCC and
Binutils. Installing these will vary based on your operating
system. For my particular Linux distribution (Arch), I simply ran:

{% highlight shell %}
$ sudo pacman -S arm-none-eabi-gcc
{% endhighlight %}

# Getting Started

To begin, we'll create our project and set it to use nightly Rust.

{% highlight shell %}
$ cargo new --bin teensy
$ cd teensy
$ rustup override set nightly
{% endhighlight %}

The first thing we need to do is make an embedded-friendly
binary. We'll replace the default `src/main.rs` with the following:

{% highlight rust %}
#![feature(lang_items,asm)]
#![no_std]
#![no_main]

#[no_mangle]
pub extern fn main() {
    loop{}
}
{% endhighlight %}

What does all of this do? The `no_std` attribute tells Rustc that we
don't want the Rust standard library. We will still have access to
everything in `core` (and, later, `collections`). Most of the standard
library contains too many things that depend on a real operating
system - for example, we don't have a filesystem in the embedded
world.

The other changes to `src/main.rs` are also for the needs of embedded
development. The `no_main` attribute tells `rustc` to skip its normal
shim around the main function. This shim typically handles things like
parsing arguments which, like filesystems, do not exist in our
emebedded world. Our main function is now marked `no_mangle` and `pub
extern`. This set of flags amounts to telling the Rust compiler, "Make
our main function look exactly like a C function". This is needed to
use the function as the reset vector in our interrupt table.

The other bit of setup is to add a handler for any panics that
occur. We'll add that to the bottom `src/main.rs`:

{% highlight rust %}
#[lang = "panic_fmt"]
#[no_mangle]
pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,
                               _file: &'static str,
                               _line: u32) -> ! {
    loop {};
}
{% endhighlight %}

Normally panics are handled by Rust's libstd. Because we cannot use
that library, we are forced to handle panics ourselves. This panic
handler currently does nothing, but in a future post we will enable
the MK20DX256's serial port, and use that to output error messages on
panics.

# Interrupt Table

As we said above, the MK20DX256 μC starts by calling the reset vector
in its interrupt table. The processor expects this table to exist at
the start of the flash memory. Let's set up that table in our
`src/main.rs` for now.

{% highlight rust %}
extern {
    fn _stack_top();
}

#[link_section = ".vectors"]
#[no_mangle]
pub static _VECTORS: [unsafe extern fn(); 2] = [
    _stack_top,
    main,
];
{% endhighlight %}

The μC we're using actually has over one hundred interrupts
available. For startup, though, we only need two:

1. The initial stack pointer. This is not really an interrupt, but is
   stored in the interrupt table anyway.
2. The reset vector, as discussed above.

Note that `_stack_top` is **not** a function. It is a symbol that will
be exported by our linker, representing an address in the μC's
memory. We pretend that it is a function for purposes of the interrupt
table, since every other value in that table is a function.

Also of note is that `#[no_mangle]` is necessary here. Even though we
never rely on the unmangled name of this array, Rust uses that
attribute as a signal that the variable has special meaning to the
linker. If we do not include it, the interrupt table will be missing
from our final executable.

# Flash Configuration

The MK20DX256 uses a series of 16 bytes at address 0x400 to control
how the flash memory is accessed. For details on this, see the
manufacturer's data sheet, §28.3.1 "Flash Configuration Field
Description". For our purposes, we will leave the flash
unsecured. This allow's the Teensy's bootloader chip to function as
expected.

The flash configuration is a simple array of bytes in `src/main.rs`.

{% highlight rust %}
#[link_section = ".flashconfig"]
#[no_mangle]
pub static _FLASHCONFIG: [u8; 16] = [
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xDE, 0xF9, 0xFF, 0xFF
];
{% endhighlight %}

As before, the `#[no_mangle]` attribute is needed to signal the Rust
compiler that we intend for this data to be accessed outside of our
program.

# Linking

We stated earlier that the interrupt table needs to be at the start of
the μC's flash. In this section, we will show how to ensure that is
the case. We will also specify the `_stack_top` symbol that was
referenced in the previous section. There are two parts to this. The
first is to tell Rust that we require special linker options. Then, we
will create a *linker script* to lay out our program in the flash
memory.

To tell Rust to use our linker configuration, we need to create a
`.cargo/config` file:

{% highlight toml %}
[target.thumbv7em-none-eabi]
rustflags = [
    "-C", "link-arg=-Tlayout.ld",
    "-C", "link-arg=-nostartfiles",
]
{% endhighlight %}

This tells Rust that we do not want to link to any default
initialization files, and that we have a custom *linker script*. GCC
does not actually include any default initialization files for our μC,
and would throw a linker error without the `-nostartfiles` flag. The
linker script is what describes where in flash and RAM the various
parts of our program will reside.

The linker script looks like this:

```
MEMORY
{
	FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 256K
	RAM  (rwx) : ORIGIN = 0x1FFF8000, LENGTH = 64K
}

SECTIONS
{
    .text : {
        . = 0;
        KEEP(*(.vectors))
        . = 0x400;
        KEEP(*(.flashconfig*))
        *(.text*)
    } > FLASH = 0xFF

    _stack_top = ORIGIN(RAM) + LENGTH(RAM);
}
```

First, we declare the two sections of memory available on our chip -
FLASH and RAM. RAM is 64KiB centered on address 0x20000000 (See §3.5.3
of the MK20DX256 reference manual). FLASH is 256KiB at the bottom of
the address space.

We next lay out our program in the flash. The first 1024 bytes have to
be our interrupt table. Each interrupt vector is 4 bytes, and there
are 256 possible vectors. Since our actual interrupt table is much
smaller than this, we skip ahead to address 0x400 (1024), where the
flash configuration goes. After the flash configuration, we have free
reign over the layout. For now, all we have to add is our program code
from the `.text` section.

Lastly, we specify the `_stack_top` symbol that we referenced
earlier. For now we'll put the stack at the top of RAM. It will grow
down as functions are called.

At this point, the project can be built and flashed to a Teensy,
although it won't do anything. Let's fix that by turning on the LED.

# Turning on the Lights

The I/O pins of a μC are global mutable resources. An important part
of Rust is that it does not allow mutable globals (except with
`unsafe`, of course). Thus, we should build abstractions that let us
use safe Rust for these unsafe low-level resources. This section will
cover building those abstractions for the hardware components needed
to turn on the Teensy's LED.

## The Watchdog

If you remember from the start of this article, the first thing to do
is disable the *watchdog*. This will prevent the μC from rebooting
itself at random during our experiments.

We'll create a `src/watchdog.rs` file to control the watchdog. The
watchdog is controlled by 24 bytes of memory at address 0x40052000, as
described in §23.7 of the MK20DX256 manual.

To disable the watchdog, we need to first write special values to the
`unlock` register, then unset the ENABLE bit in the watchdog control
register.

Our implementation looks like this:

{% highlight rust %}
use core;

#[repr(C,packed)]
pub struct Watchdog {
    stctrlh: u16,
    stctrll: u16,
    tovalh: u16,
    tovall: u16,
    winh: u16,
    winl: u16,
    refresh: u16,
    unlock: u16,
    tmrouth: u16,
    tmroutl: u16,
    rstcnt: u16,
    presc: u16
}

impl Watchdog {
    pub unsafe fn new() -> &'static mut Watchdog {
        &mut *(0x40052000 as *mut Watchdog)
    }

    pub fn disable(&mut self) {
        unsafe {
            core::ptr::write_volatile(&mut self.unlock, 0xC520);
            core::ptr::write_volatile(&mut self.unlock, 0xD928);
            asm!("nop" : : : "memory");
            asm!("nop" : : : "memory");
            let mut ctrl = core::ptr::read_volatile(&mut self.stctrlh);
            ctrl &= !(0x00000001);
            core::ptr::write_volatile(&mut self.stctrlh, ctrl);
        }
    }
}
{% endhighlight %}

The `nop` asm blocks are there due to instructions in §23.3.1 to "Wait
one bus clock cycle". Typically the bus will be clocked no slower than
1/2 the core CPU clock. We will discuss clocking in-depth in a future
post. Marking the `asm` blocks as modifying `memory` ensures that the
compiler does not re-order them with our volatile writes to control
registers.

You will note that the `new` method is `unsafe`, but the `disable`
method is not, even though the entire body of that function is
unsafe. This is due to the invariants of watchdog control. As long as
only one piece of code is accessing the watchdog, making changes to it
is completely safe. If two independant sections of code make changes
to the watchdog, they could conflict. Thus, creating a new instance of
the Watchdog struct is unsafe - you have to be sure you're the only
piece of code controlling it. But once you have a Watchdog instance,
you can modify it as much as you'd like.

This pattern of unsafe construction, safe modification will be common
in our hardware wrappers.

## Clock Gating

Most functions of our μC are controlled by separate *clocks*. Each of
these clocks can be turned on or off via the *System Integration
Module*, or SIM. Just like the watchdog, we will represent the SIM as
a struct at a particular memory address. This memory layout is
described in §12.2 of the MK20 manual.

Just like the watchdog, our SIM wrapper is unsafe to construct but
safe to use (provided you only construct one of them). The SIM memory
layout includes a lot of funtionality we're not using yet, but writing
out the whole struct will make it easier for us to get there later.

Let's go ahead and create `src/sim.rs`, with the following content:

{% highlight rust %}
use core;

pub enum Clock {
    PortC,
}

#[repr(C,packed)]
pub struct Sim {
    sopt1: u32,
    sopt1_cfg: u32,
    _pad0: [u32; 1023],
    sopt2: u32,
    _pad1: u32,
    sopt4: u32,
    sopt5: u32,
    _pad2: u32,
    sopt7: u32,
    _pad3: [u32; 2],
    sdid: u32,
    _pad4: [u32; 3],
    scgc4: u32,
    scgc5: u32,
    scgc6: u32,
    scgc7: u32,
    clkdiv1: u32,
    clkviv2: u32,
    fcfg1: u32,
    fcfg2: u32,
    uidh: u32,
    uidmh: u32,
    uidml: u32,
    uidl: u32
}

impl Sim {
    pub unsafe fn new() -> &'static mut Sim {
        &mut *(0x40047000 as *mut Sim)
    }

    pub fn enable_clock(&mut self, clock: Clock) {
        unsafe {
            match clock {
                Clock::PortC => {
                    let mut scgc = core::ptr::read_volatile(&mut self.scgc5);
                    scgc |= 0x00000800;
                    core::ptr::write_volatile(&mut self.scgc5, scgc);
                }
            }
        }
    }
}
{% endhighlight %}

For now, this only handles enabling the clock for Port C. Each block
of functionality in our μC can be enabled separately. We'll update
this file as we need additional bits of hardware.

## I/O Ports

Each pin of the MK20DX256 is associated with one of five ports,
labeled "a" through "e". Within each port, the individual pins can be
associated with various functions of the chip. They may be simple
outputs (or inputs), or they may be connected to a more complex piece
of functionality, such as a serial interface.

In the previous section, we allowed enabling of the Port C clock. Port
C is where the LED lives, so it's all that we need for this
tutorial. In this section, we will use our newly-enabled Port C to
turn on the LED.

As with the previous two sections, we will create a new file:
`src/port.rs`. This file will include the structs and impls for
handling the μC's I/O ports. We'll start with the following:

{% highlight rust %}
use core;

pub enum PortName {
    C
}

#[repr(C,packed)]
pub struct Port {
    pcr: [u32; 32],
    gplcr: u32,
    gpchr: u32,
    reserved_0: [u8; 24],
    isfr: u32,
    reserved_1: [u8; 28],
    dfer: u32,
    dfcr: u32,
    dfwr: u32
}

impl Port {
    pub unsafe fn new(name: PortName) -> &'static mut Port {
        &mut * match name {
            PortName::C => 0x4004B000 as *mut Port
        }
    }


}
{% endhighlight %}

This lets us construct a port, but doesn't let us access individual
pins, or associate them with a piece of hardware functionality.

For the purpose of turning on our LED, we need to be able to grab an
I/O pin, put it in GPIO (General Purpose I/O) mode, and switch it to a
"high" output. There are two ways to do this:

1. Make it all `unsafe`. In this world, claiming a pin for GPIO use
   isn't exclusive, and we rely on the programmer to ensure she does
   not have conflicts with her pin usage.
2. Use something similar to `RefCell`, where we panic if there is a
   conflict in how pins are used.

For now, we'll use the first way - flag it all as unsafe. In a future
post, we will explore how to expand the pin API to enforce safety at
run time. We'll add the following to `src/port.rs`:

{% highlight rust %}
pub struct Pin {
    port: &'static Port,
    pin: u32
}

impl Port {
     pub unsafe fn pin(&mut self, p: u32) -> Pin {
        let myself = &mut * (self as *mut Port);
        Pin { port: myself, pin: p }
    }
}
{% endhighlight %}

The cast back-and-forth between reference, pointer, and reference
converts our generic `self` reference to a static one. This is safe
for us, since we know that any given `Port` instance points to
somewhere in the μC's configuration space, and is thus static.

Now that we can get a pin, we need to be able to switch it to GPIO
output, and turn it on. We'll add that to the `Pin` impl in
`src/ports.rs`. You will note that when you convert a pin to a GPIO,
the Pin object is consumed. This is intentional - it ensures that the
pin cannot be re-used for another purpose.

{% highlight rust %}
impl Pin {
    pub fn make_gpio(self) -> Gpio {
        unsafe {
            self.port.ctrls()[self.pin as usize] = 0x00000100;
            Gpio::new(PortName::C, 5)
        }
    }
}
{% endhighlight %}

The new `Gpio` struct represents a single pin that is acting as a GPIO
device.

{% highlight rust %}
#[repr(C,packed)]
pub struct _Gpio {
    pdor: u32,
    psor: u32,
    pcor: u32,
    ptor: u32,
    pdir: u32,
    pddr: u32
}

pub struct Gpio {
    gpio: &'static mut _Gpio,
    pin: u32
}

impl Gpio {
    pub unsafe fn new(port: PortName, pin: u32) -> Gpio {
        let addr = match port {
            PortName::C => 0x400FF080 as *mut _Gpio
        };

        Gpio { gpio: &mut *addr, pin: pin }
    }

    pub fn output(&mut self) {
        unsafe {
            core::ptr::write_volatile(&mut self.gpio.pddr, 1 << self.pin);
        }
    }

    pub fn high(&mut self) {
        unsafe {
            core::ptr::write_volatile(&mut self.gpio.psor, 1 << self.pin);
        }
    }
}

{% endhighlight %}

This is a lot of new code. The hardware interface is the `_Gpio`
struct. This represents up to 32 GPIO pins, associated with a single
port (see §47.2 for details of the GPIO mempory layout).  So far,
we've only defined this for Port C. This structure is not publicly
visible - it is used as an implementation detail of the `Gpio` struct,
which represents a single pin.

The `Gpio` impls allow setting a pin as an output, and then setting it
as "high". This is a subset of the real GPIO functionality, but is all
that we need to enable the Teensy's LED.

## Putting it Together

The previous sections have added the necessary code to:

* Disable the hardware watchdog
* Enable our I/O port
* Set the appropriate pin as high

With those pieces in place, we can update our main program to turn on
our LED. We will update `src/main.rs` as follows:

{% highlight rust %}
mod port;
mod sim;
mod watchdog;

#[no_mangle]
pub extern fn main() {
    let (wdog,sim,pin) = unsafe {
        (watchdog::Watchdog::new(),
         sim::Sim::new(),
         port::Port::new(port::PortName::C).pin(5))
    };

    wdog.disable();
    sim.enable_clock(sim::Clock::PortC);

    let mut gpio = pin.make_gpio();

    gpio.output();
    gpio.high();

    loop {}
}
{% endhighlight %}

We first get the needed references to each memory-mapped hardware
device. In practice, this entire unsafe block is inlined, and the
appropriate hardware addresses are used directly in the rest of
`main`.

Once we have the individual hardware control blocks, we follow the
procedure outlined near the start of this post:

* Disable the watchdog
* Enable Port C
* Set C.5 high to turn on the LED.

This is the end of our Rust code. Now we'll create a Makefile to
simplify the build/flash process, and run the actual program on the
Teensy.

# Installing on the Teensy

To make building our project easy, we'll create a `Makefile`. This
will make it possible to build and install our project without needing
to remember complex command lines.

Our Makefile looks like this:

{% highlight make %}
BIN=teensy
OUTDIR=target/thumbv7em-none-eabi/release
HEX=$(OUTDIR)/$(BIN).hex
ELF=$(OUTDIR)/$(BIN)

all:: $(HEX)

$(HEX): $(ELF)
	arm-none-eabi-objcopy -R .stack -O ihex $(ELF) $(HEX)

.PHONY: $(ELF)
$(ELF):
	~/.cargo/bin/xargo build --target=thumbv7em-none-eabi --release

flash: $(HEX)
	teensy-loader-cli -w -mmcu=mk20dx256 $(HEX) -v
{% endhighlight %}

For those familiar with make, this is pretty simple. If you're not
familiar with make, that's OK - all this does is give us a simpler way
to build and install our project. Each line with a colon is a
"target", which is something that can be built. The indented lines
under each target are the commands needed to build it. So we have a
`flash` target, which depends on a `$(HEX)` target. The `$(HEX)`
target depends on `$(ELF)`, which is "phony" - a phony target is
always built. Thus, when you run `make flash`, we will first compile
the Rust code with xargo (via the `$(ELF)` target). That compiled
binary will then be converted to a format that can be installed to the
teensy (the `$(HEX)` target). Lastly, the program will be installed to
the Teensy itself (the actual `flash` target).

So, to install our new program to our Teensy, all we need to do is run
the following:

{% highlight shell %}
$ make flash
{% endhighlight %}

If all goes well, you will end up with the LED of your teensy shining
bright orange.

# Next Steps

The next few posts will deal with enabling further functionality of
the μC, and improving safety. We'll first enable the PLL so that the
μC runs at its full clock speed. We'll then look in to enabling a
serial port, and eventually USB for debugging purposes.